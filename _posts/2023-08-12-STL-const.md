---
title: C++ STL(Standard Template Library)에 대해 배워보자 - 상수형(const) 객체, 메서드
author: orion
date: 2023-08-12 22:21:00 +0900
categories: [Programming, C++, STL]
tags: [C++, STL, Standard Template Library, const]
---

><details>
><summary>목차</summary>
><div markdown="1">
>- [C++ STL(Standard Template Library)에 대해 배워보자](https://orion-gz.github.io/posts/STL/ "STL 목차")<br>
>- [Chap01 : 연산자 오버로딩](https://orion-gz.github.io/posts/STL-Chap01/ "Chap01 : 연산자 오버로딩")<br>
>- Chap02 : 함수 포인터<br>
>- Chap03 : 함수 객체<br>
>- Chap04 : 템플릿<br>
>- Chap05 : STL 소개<br>
>- Chap06 : 시퀀스 컨테이너<br>
>- Chap07 : 연관 컨테이너<br>
>- Chap08 : 알고리즘<br>
>- Chap09 : STL 함수 객체<br>
>- Chap10 : 반복자<br>
>- Chap11 : 컨테이너 어댑터<br>
>- Chap12 : String 컨테이너<br>
>- 참고하면 좋은 내용들<br>
></div>
></details> 
{: .prompt-info }

> 해당 글은 `공동환 저자`  [`뇌를 자극하는 C++ STL`](https://hanbit.co.kr/store/books/look.php?p_code=B5912645820 "한빛미디어 - 뇌를 자극하는 C++ STL") 도서 기반으로 작성되었습니다.
{: .prompt-info }

> 해당 코드는 다음과 같은 환경에서 실행되었습니다.  
> 개발 환경 : M2 Macbook Pro 14, `Sonoma 14.0`   
> IDE : `CLion`  
> Language Standard Version : `C++17`  
{: .prompt-tip }

## 들어가며
Chap01을 설명하면서 상수형 객체와 메서드에 대해 `매우 중요한` 부분이라 따로 짚고 넘어간다 했었는데요. 이번 글에서 상수형 객체, 상수형 메서드가 무엇인지, 그리고 왜 사용하여야 하는지, 주의해야할 점과 중요한 점은 무엇인지 한번 다루어 보도록 하겠습니다! 깃허브에 작성된 코드는 따로 없고, 본문에 있는 코드 참고해주시면 되겠습니다!

> **중요 포인트는요!**
>  
> 지금과 같이 `노란색 박스`에는 `주의사항`이 `초록색 박스`에는 `팁 / 참고사항`이 있으니  
>  꼭 읽어보시길 권합니다! `중요한 내용`이 담겨 있습니다!!  
{: .prompt-warning}

## 01. const 키워드
먼저 `const` 키워드에 대해 알아보겠습니다. const 키워드는 값을 상수로 지정하는 키워드로 프로그래머가 수정하지 못하도록 컴파일러에 지시합니다. `선언과 동시에 초기화` 해야하며, 초기화 이후에는 `값을 변경할 수 없습니다.` 만약 객체의 값이 변경되면 안되는 상황에 쓰면 매우 유용합니다. 사용자, 개발자의 실수를 방지할 수 있으니까요.

사용하는 방법은 정말 간단합니다. 자료형 타입 앞에 const 선언을 해주면 됩니다. 그럼 `const` 키워드를 어떻게 사용하는지에 대해 알아보겠습니다.

### const 비 멤버 변수
일반적으로 클래스 내부의 멤버 변수가 아닌 경우의 const 변수입니다. 사용 방법은 비교적 간단합니다.

```c++
const int a = 10;
int const a = 10; // 위와 같은 의미

// a = 20; error: read-only variable is not assignable
```
{: file="const 비 멤버 변수"}

위 코드에서 단순히 `int` 자료형 앞에 키워드를 붙여주면 됩니다. `const` 선언이 붙은 이 객체는 상수가 되며, 값을 변경할 수 없게 됩니다. 

아래에 있는 `int const`도 동일한 의미를 지니고 있으나, 보통 `const int` 라는 표현을 많이 사용합니다.

### const 멤버 변수
클래스 내부에 정의된 const 멤버 변수의 사용 방법입니다.

```c++
#include <iostream>
using namespace std;

class Test
{
    const int num;  // 1. 생성자 초기화 리스트 사용
    const int num2 = 10;  // 2. 선언 및 초기화 사용(C++11 부터 사용 가능)
public:
    Test(int n)
        : num(n)
    {

    }

    void Print() const
    {
        cout << num << endl;
        cout << num2 << endl;
    }
};

int main()
{
    Test t(10);
    t.Print();

    return 0;
}
```
{: file="const 멤버 변수"}

const 키워드는 `선언과 동시에 초기화` 해야된다고 앞서 말씀 드렸었는데요. 클래스 내부에 멤버 변수로 정의되어 있을 경우 다음과 같이 사용이 가능합니다.

1. `생성자 초기화 리스트 사용`
    * `const int num = n;` 과 동일합니다.
    *  class 내부에서 `const int num`을 정의한 것은 객체 생성시 메모리 할당과 동시에 초기화 리스트가 호출되어 초기화가 가능합니다.
    *  즉, class 내부에 정의된 상수 멤버 변수는 초기화 리스트가 아닌 함수나 생성자 안에서 초기화 될 수 없습니다.
  

2. `선언 및 초기화 사용(C++11 부터 사용 가능)`
   * `const int num2 = 10;` 과 같이 선언과 동시에 초기화가 가능합니다.
   * class 생성자 호출시 초기화 되는 것이 아닌 프로그램 실행시 초기화 됩니다.

### const 포인터 변수
그럼 다음과 같은 코드는 어떨까요?

```c++
int num = 10;

const int* a =  &num;  //  1. pointer to constant (상수 지시 포인터)
int* const b = &num;  // 2. constant pointer (상수 포인터)
const int* const c = &num;  // 3. constant pointer to constant (상수 지시 상수 포인터)
```
{: file="const 포인터 활용"}

정말 어지럽죠.. 포인터만 해도 어려운데 상수 선언까지 양옆으로 되어 있으니 뭐가 뭔지 구분하기 어렵습니다.<br><br>

#### 1. **pointer to constant (상수 지시 포인터)**
`const int* a = &num;`는 상수 지시 포인터로 `포인터가 가리키는 값 자체가 상수`임을 뜻합니다. 

즉, 가리키는 값 자체인 `int num = 10;`이 상수는 아니지만, `가리키는 값을 변경하지 못한다`는 뜻입니다. 

단, `포인터 주소 자체`는 바꿀 수 있습니다.
```c++
#include <iostream>
using namespace std;

int main()
{
    int num = 10;
    int num2 = 20;

    const int* a = &num;
    cout << *a << endl;

    a = &num2;
    cout << *a << endl;

    // *a = 20;  error: read-only variable is not assignable

    return 0;
}
```
{: file="pointer to constant"}

> [출력 결과]  
> 10  
> 20  
{: .prompt-success}

#### 2. **constant pointer (상수 포인터)**
`int* const b = &num;`는 상수 포인터로 `포인터의 주소값이 상수`임을 뜻합니다.

위의 경우와는 반대로 가리키는 값 자체인 `int num = 10;`을 변경할 수 있지만, `포인터 주소 자체는 변경하지 못합니다.`

```c++
#include <iostream>
using namespace std;

int main()
{
    int num = 10;
    int num2 = 20;

    int* const b = &num;
    cout << *b << endl;

    *b = 20;
    cout << *a << endl;

    // b = &num2;  error: cannot assign to variable 'b' with const-qualified type 'int *const'

    return 0;
}
```
{: file="constant pointer"}

> [출력 결과]  
> 10  
> 20  
{: .prompt-success}

#### 3. **constant pointer to constant (상수 지시 상수 포인터)**
`const int* const c = &num;`는 상수 지시 상수 포인터로 위 두가지 경우를 합친 것과 같습니다.

즉, `포인터가 가리키는 값의 변경이 불가능`하며, `포인터의 주소 또한 변경이 불가능`합니다.

```c++
#include <iostream>
using namespace std;

int main()
{
    int num = 10;
    int num2 = 20;

    const int* const c = &num;
    cout << *c << endl;

    
    cout << *c << endl;
    // *c = 20;  error: read-only variable is not assignable
    // c = &num2;  error: cannot assign to variable 'c' with const-qualified type 'int *const'

    return 0;
}
```
{: file="constant pointer"}

> [출력 결과]  
> 10  
> 10  
{: .prompt-success}

정리하자면 다음과 같습니다.

| 타입                 | 포인터가 가리키는 값을 변경할 수 있는가? | 포인터의 주소를 변경할 수 있는가? |
|:-------------------:|:------------------------------:|:-------------------------:|
| const int* a = &num | X                              | O                         |
| int* const b = &num | O                              | X                         |
| const int* const c = &num | X                        | X                         |

const 포인터 변수와 비슷한 자매품이 STL에 있는데요.
바로 `반복자` 입니다. 지금 자세히 알아보지는 않겠지만, 위의 경우와 비슷하다고 보시면 됩니다.

```c++
vector<int> v;

v.push_back(10);
v.push_back(20);
v.push_back(30);

vector<int>::iterator iter = v.begin();
vector<int>::const_iterator citer = v.begin();
const vector<int>::iterator iter_const = v.begin();
const vector<int>::const_iterator citer_const = v.begin();
```
{: file="반복자와 const 키워드"}

지금은 가볍게 보기만 하고 넘어가시면 될 것 같습니다.

## 02. 상수형 메서드
상수형 메서드는 함수 원형 뒤에 `const` 키워드로 선언된 함수로 멤버 변수에 읽기 접근은 가능하지만, 쓰기는 허용되지 않는 메서드를 말합니다. 

`모든 멤버 변수들이 상수화 됩니다.`

```c++
#include <iostream>
using namespace std;

class Test
{
public:
    Test(int num)
        : nData(num)
    {

    }

    ~Test() { }

    // 상수형 메서드 선언 및 정의
    int GetData() const
    {
        return nData;  // 멤버 변수의 값을 읽을 수 있지만, 쓸 수는 없음.
    }

    void SetData(int n)
    {
        nData = n;
    }

    // 상수형 메서드 선언 및 정의
    void Print() const
    {
        cout << GetData() << endl; // 상수형 메서드에서는 오직 상수형 메서드만 호출 가능!
    }
private:
    int nData = 0;
}

int main()
{
    Test t(10);
    t.Print();

    return 0;
}
```
{: file="상수형 메서드"}

상수형 메서드로 정의된 `GetData()` 함수는 멤버 변수의 값을 변화하거나 변화를 일으킬 가능성이 없습니다. 또한, 상수화된 메서드가 아니라면 멤버 함수라 하더라도 호출이 불가능해집니다. 

즉, 다음과 같은 코드는 허용되지 않습니다.

```c++
int GetData() const
{
    SetData(20);  // 상수형 메서드가 아닌 멤버 함수는 호출 불가 Error!

    return nData;  // 멤버 변수의 값을 읽을 수 있지만, 쓸 수는 없음.
}
```
{: file="상수형 메서드의 멤버 함수 호출"}

위 코드를 실행시켜 보면 다음과 같은 에러가 발생합니다.

> <span style="color:red">error:</span> 'this' argument to member function 'SetData' has type 'const Test', but function is not marked const
{: .prompt-danger }

> **여기서 중요한 점은**  
> 
> 에러 메시지를 보면 "`SetData()` 를 호출한 `this` 포인터의의 타입은 `const Test` 인데, `함수의 타입은 const` 가 아니다." 라고 나와있습니다. 이를 통해 상수형 메서드의 특징을 알 수 있습니다.  
> 
> 바로 상수형 메서드의 상수화 방법은 `"this 포인터를 상수 지시 포인터(pointer to constant)로 변경하는 것"` 입니다. 아까 위에서 다룬 내용 [`const 포인터 변수`](https://orion-gz.github.io/posts/STL-const/#const-포인터-변수 "const 포인터 변수")와 같이 this 포인터의 형식이 `Test *this;` 이 아닌 `const Test *this;` 라는 것 입니다.  
{: .prompt-warning}

따라서 다음과 같은 코드 역시 불가능합니다.

```c++
int GetData() const
{
    nData = 20;  // 멤버 변수의 값을 쓸 수 없음 Error!

    return nData;  // 멤버 변수의 값을 읽을 수 있지만, 쓸 수는 없음.
}
```
{: file="상수형 메서드와 멤버 변수"}

여기서 `nData` 는 `this->nData`와 같습니다. 하지만, `this` 포인터의 타입이 `const Test* (상수 지시 포인터)` 이기 때문에 포인터가 가리키는 값을 변경할 수 없게 됩니다.

결론은 다음과 같습니다.

> `상수형 메서드`는 절대로(혹은 문법적으로) `멤버 변수의 값을 쓸 수 없고`, `상수형 메서드가 아닌 멤버는 호출할 수 없다.`
{: .prompt-info}

## 03. 상수형 객체
`const` 키워드가 붙은 객체. 바로 이것을 상수형 객체라고 합니다. 이 `const 객체` 는 멤버 변수들이 모두 상수화 됩니다.

위에서 상수형 메서드를 다루면서, `"상수형 메서드의 상수화 방법은 this 포인터를 상수 지시 포인터로 바꾼다."`고 했었습니다. 상수형 객체에서도 동일합니다. 

```c++
#include <iostream>
using namespace std;

class Test
{
public:
    Test(int num)
            : nData(num)
    {

    }

    ~Test() { }

    // 상수형 메서드 선언 및 정의
    int GetData() const
    {
        return nData;  // 멤버 변수의 값을 읽을 수 있지만, 쓸 수는 없음.
    }

    void SetData(int n)
    {
        nData = n;
    }

    // 상수형 메서드 선언 및 정의
    void Print() const
    {
        cout << GetData() << endl; // 상수형 메서드에서는 오직 상수형 메서드만 호출 가능!
    }
private:
    int nData = 0;
};

int main()
{
    const Test t(10);  // 단, 생성자 초기화 리스트를 통한 변수 초기화는 가능!
    t.SetData(20);  // 상수형 객체는 오직 상수형 메서드만 호출 가능 Error!

    t.Print(); // 상수형 객체는 오직 상수형 메서드만 호출 가능!

    return 0;
}
```
{: file="상수형 객체"}

> <span style="color:red">error:</span> 'this' argument to member function 'SetData' has type 'const Test', but function is not marked const
{: .prompt-danger }

객체 자신인 this 포인터가 상수 지시 포인터이기 때문에 멤버 변수의 값을 변경하지 못합니다. 따라서 `상수형 메서드만 호출이 가능`합니다.

> `상수형 메서드` 혹은 `상수형 객체`가 호출하는 함수는 상수 함수임이 보장되어야 하기 때문에 멤버 변수의 값을 변경하지 않더라도, `const가 선언되지 않은 함수는 호출할 수 없습니다.`  
>
> `const` 선언을 해줌으로써 컴파일러에 해당 함수가 `값을 변경하지 않는 const 함수`라는 것을 지시(보장) 합니다.  
{: .prompt-tip}


## 04. 상수형 메서드의 예외 사항
지금까지 간단하게 `const 메서드` 와 `const 객체` 에 대해 알아보았습니다. `const` 키워드 자체는 컴파일러로 하여금 값을 변경시키지 못하게 하는 것이지만, 프로그래밍에서 예외 사항은 꼭 존재합니다. 그때 사용할 수 있는게 바로 `mutable` 키워드 와 `const_cast<>` 형변환 연산자 입니다.

이 두가지 모두 상수화 된 대상에서 `const` 예약어가 지정된 멤버를 뽑아 값을 쓰거나 호출할 수 있습니다.

### mutable 키워드
다음과 같이 `mutable` 로 선언한 멤버 변수의 값은 상수형 메서드에서 쓰기가 허용됩니다.

```c++
#include <iostream>
using namespace std;

class Test
{
public:
    Test(int num)
            : nData(num)
    {

    }

    ~Test() { }

    // 상수형 메서드 선언 및 정의
    int GetData() const
    {
        nData = 20;  // mutable 로 선언된 멤버 변수는 쓸 수 있음.
        return nData;  
    }

    void SetData(int n)
    {
        nData = n;
    }

    // 상수형 메서드 선언 및 정의
    void Print() const
    {
        cout << GetData() << endl; // 상수형 메서드에서는 오직 상수형 메서드만 호출 가능!
    }
private:
    mutable int nData = 0;
};

int main()
{
    const Test t(10);  // 생성자 초기화 리스트를 통한 변수 초기화는 가능!

    t.Print(); // 상수형 객체는 오직 상수형 메서드만 호출 가능!

    return 0;
}
```
{: file="mutable 키워드"}

> [출력 결과]  
> 20  
{: .prompt-success}

위 코드에서 `GetData()` 함수가 상수형 메서드임에도 `mutable`로 선언된 멤버 변수의 값은 상수형 메서드에서도 쓰기가 허용됩니다.

```c++
class Test
{
public:
    ...

    // 상수형 메서드 선언 및 정의
    int GetData() const
    {
        return nData;
    }

    void SetData(int n)
    {
        nData = n;
    }

    // 상수형 메서드 선언 및 정의
    void Print() const
    {
        cout << GetData() << endl; // 상수형 메서드에서는 오직 상수형 메서드만 호출 가능!
    }
private:
    mutable int nData = 0;
};

int main()
{
    const Test t(10);  // 생성자 초기화 리스트를 통한 변수 초기화는 가능!

    // t.SetData(20);  상수형 객체는 오직 상수형 메서드만 호출 가능 Error!
    t.nData = 20;  // mutable 로 선언된 멤버 변수는 쓸 수 있음.
    
    t.Print();

    return 0;
}
```
> [출력 결과]  
> 20  
{: .prompt-success}

상수형 메서드에서의 쓰기와 마찬가지로 `상수형 객체`에서도 `mutable`로 선언된 멤버 변수의 값에 쓰기가 가능합니다.

### const_cast<> 형변환 연산자
또한, 상수형 참조인 경우 참조자를 통해 참조 원본에 접근하더라도 읽기만 허용될 분 쓰기는 불가능합니다. 그러나 가끔 억지로라도 쓰기를 해야하는 경우가 있는데, 이럴 때 `const_cast<>` 를 사용합니다.

```c++
#include <iostream>
using namespace std;

// 상수형 참조의 nParam를 매개변수로 받음
void func(const int& nParam)
{
    // 상수형 참조였으나 일반 참조로 형변환
    int &nNewParam = const_cast<int &>(nParam);

    // 쓰기 가능.
    nNewParam = 20;
}

int main()
{
    int nData = 10;

    func(nData);

    cout << nData << endl;

    return 0;
}
```
{: file="const_cast<> 형변환 연산자"}

> [출력 결과]  
> 20  
{: .prompt-success}

위코드에서`func()` 함수의 매개변수 형식은 `const int&`로 정수 상수형 참조입니다. 이것을 `const_cast<>` 를 사용하여 상수형 참조 대상을 일반 참조로 변경할 수 있습니다.

const_cast<> 의 형태는 다음과 같습니다.

> const_cast<새 형식>(대상)  
{: .prompt-tip}

